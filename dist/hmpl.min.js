!function(e,t){"object"==typeof module&&module.exports?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.hmpl=e.hmpl||t()}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";const e=e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,t=e=>"[object Function]"===Object.prototype.toString.call(e),o=e=>{throw new Error(e)},n=e=>{console.warn(e)},s="method",r="initId",i="after",l="repeat",d="memo",c="indicators",a="autoBody",p="hmpl",f="formData",u="allowedContentTypes",h="BadResponseError",m="RequestInitError",y="RenderError",g="RequestObjectError",$="CompileOptionsError",b="ParseError",v="CompileError",N={formData:!0},w={formData:!1},T=/(\{\{(?:.|\n|\r)*?\}\}|\{\s*\{(?:.|\n|\r)*?\}\s*\})/g,E=/([{}])|([^{}]+)/g,O=["src",s,r,i,l,c,d,a,u],P=[100,101,102,103,300,301,302,303,304,305,306,307,308,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,421,422,423,424,425,426,428,429,431,451,500,501,502,503,504,505,506,507,508,510,511],j=["text/html"],k=e=>(new DOMParser).parseFromString(`<template>${e}</template>`,"text/html").childNodes[0].childNodes[0].firstChild,x=(t,s,r,i,l,d,c,a,p={},f,u,g,$)=>{const{mode:b,cache:v,redirect:N,get:w,referrerPolicy:T,signal:E,credentials:O,timeout:P,referrer:j,headers:x,body:C,window:I,integrity:q}=p,A={method:i.toUpperCase()};void 0!==O&&(A.credentials=O),void 0!==C&&(A.body=C),void 0!==b&&(A.mode=b),void 0!==v&&(A.cache=v),void 0!==N&&(A.redirect=N),void 0!==T&&(A.referrerPolicy=T),void 0!==q&&(A.integrity=q),void 0!==j&&(A.referrer=j);const D=void 0!==E;if(D&&(A.signal=E),void 0!==I&&(A.window=I),void 0!==p.keepalive&&n(`${m}: The "keepalive" property is not yet supported`),x)if(e(x)){const e=new Headers;for(const t in x){const n=x[t],s=typeof n;"string"===s?e.set(t,n):o(`${m}: Expected type string, but received type ${s}`)}A.headers=e}else o(`${m}: The "headers" property must contain a value object`);P&&(D?n(`${m}: The "signal" property overwrote the AbortSignal from "timeout"`):A.signal=AbortSignal.timeout(P));const R=a&&!d&&r?.memo,B=e=>"rejected"===e||"number"==typeof e&&(e<200||e>299),S=e=>{c&&(g.response=e,w?.("response",e,g)),w?.("response",s)},M=(e,n=!0,s=!1)=>{if(d)f.response=e.cloneNode(!0),w?.("response",e);else{let i=[];const l=[...(n?e.cloneNode(!0):e).content.childNodes];if(r.nodes){const e=r.parentNode;e||o(`${y}: ParentNode is null`);const t=[],n=r.nodes.length;for(let o=0;o<n;o++){const s=r.nodes[o];if(o===n-1)for(let o=0;o<l.length;o++){const n=l[o],r=e.insertBefore(n,s);t.push(r)}e.removeChild(s)}i=t.slice(),r.nodes=t}else{const e=t.parentNode,o=[],n=l.length;for(let s=0;s<n;s++){const n=l[s],r=e.insertBefore(n,t);o.push(r)}e.removeChild(t),i=o.slice(),r.nodes=o,r.parentNode=e}R&&s&&(r.memo.nodes=r.nodes,r.memo.isPending&&(r.memo.isPending=!1)),S(i)}};let F=!1;const H=()=>{if(d)f.response=void 0,w?.("response",void 0);else if(r.nodes){const e=r.parentNode;e||o(`${y}: ParentNode is null`);const t=r.nodes.length;for(let o=0;o<t;o++){const n=r.nodes[o];o===t-1&&e.insertBefore(r.comment,n),e.removeChild(n)}r.nodes=null,r.parentNode=null,c&&(g.response=void 0,w?.("response",void 0,g)),w?.("response",s)}R&&null!==r.memo.response&&(r.memo.response=null,delete r.memo.isPending,delete r.memo.nodes)},L=e=>{c?g.status!==e&&(g.status=e,w?.("status",e,g)):f.status!==e&&(f.status=e,w?.("status",e)),R&&B(e)&&(r.memo.response=null,delete r.memo.nodes),(e=>{if($)if(R&&"pending"!==e&&B(e)&&r.memo.isPending&&(r.memo.isPending=!1),"pending"===e){const e=$.pending;void 0!==e&&(R&&(r.memo.isPending=!0),M(e))}else if("rejected"===e){const e=$.rejected;if(void 0!==e)M(e);else{const e=$.error;void 0!==e?M(e):H()}}else{const t=$[`${e}`];if(e>399)if(void 0!==t)M(t);else{const e=$.error;void 0!==e?M(e):H()}else(e<200||e>299)&&(F=!0,void 0!==t?M(t):H())}})(e)};let z=200;L("pending");let U=!0;fetch(l,A).then((e=>{if(U=!1,z=e.status,L(z),Array.isArray(u)&&0!==u.length){const t=e.headers.get("Content-Type");((e,t)=>{if(!e)return!0;let o=!1;for(let n=0;n<t.length;n++){const s=t[n];if(e.includes(s)){o=!0;break}}return!o})(t,u)&&o(`${h}: Expected ${u.map((e=>`"${e}"`)).join(", ")}, but received "${t}"`)}return e.ok||o(`${h}: Response with status code ${z}`),e.text()})).then((e=>{if(!F)if(B(z))H();else{if(R){const{response:t}=r.memo;if(null===t)r.memo.response=e;else{if(t===e)return void(()=>{if(r.memo.isPending){const e=r.parentNode;e||o(`${y}: ParentNode is null`);const t=r.memo.nodes,n=r.nodes,s=n.length,i=[];for(let o=0;o<s;o++){const r=n[o];if(o===s-1)for(let o=0;o<t.length;o++){const n=t[o],s=e.insertBefore(n,r);i.push(s)}e.removeChild(r)}r.nodes=i.slice(),r.memo.isPending=!1,r.memo.nodes=i.slice()}const e=r.nodes.slice();S(e)})();r.memo.response=e,delete r.memo.nodes}}const n=(e=>{const t=k(e),o=t.content,n=o.querySelectorAll("script");for(let e=0;e<n.length;e++){const t=n[e];o.removeChild(t)}return t})(e);if(d)f.response=n,w?.("response",n);else{const e=[],o=[...n.content.childNodes];if(r)M(n,!1,!0);else{const n=t.parentNode;for(let s=0;s<o.length;s++){const r=o[s],i=n.insertBefore(r,t);c&&e.push(i)}n.removeChild(t),c&&(g.response=e,w?.("response",e,g)),w?.("response",s)}}}})).catch((e=>{throw U&&(L("rejected"),$||H()),e}))},C=(e,t=!1)=>{const n=t?$:g;"*"===e||((e,t)=>{if(!Array.isArray(e))return!1;let n=!0;for(let s=0;s<e.length;s++)if("string"!=typeof e[s]){o(`${t}: In the array, the element with index ${s} is not a string`),n=!1;break}return n})(e,n)||o(`${n}: Expected "*" or string array, but got neither`)},I=(t,n=!1)=>{const s=e(t),r=n?$:g;if("boolean"==typeof t||s||o(`${r}: Expected a boolean or object, but got neither`),s)for(const e in t)if(e===f)"boolean"!=typeof t[f]&&o(`${r}: The "${f}" property should be a boolean`);else o(`${r}: Unexpected property "${e}"`)},q=t=>{e(t)?t.hasOwnProperty("id")&&t.hasOwnProperty("value")||o(`${g}: Missing "id" or "value" property`):o(`${g}: IdentificationRequestInit must be of type object`)};return{compile:(n,f={})=>{"string"!=typeof n&&o(`${v}: Template was not found or the type of the passed value is not string`),n||o(`${v}: Template must not be a falsey value`),e(f)||o(`${$}: Options must be an object`);const h=!f.hasOwnProperty(d);h||"boolean"==typeof f[d]||o(`${$}: The value of the property ${d} must be a boolean value`);const A=!f.hasOwnProperty(a);A||I(f[a],!0);const D=!f.hasOwnProperty(u);D||C(f[u],!0);const R=[],B=n.split(T).filter(Boolean),S=[];for(const e of n.matchAll(T))S.push(e.index);0===S.length&&o(`${b}: Request not found`);const M=e=>e=(e=e.trim()).replace(/\r?\n|\r/g,""),F=(e,t)=>{const n=JSON5.parse(e);for(const e in n){const t=n[e];switch(O.includes(e)||o(`${g}: Property "${e}" is not processed`),e){case c:Array.isArray(t)||o(`${g}: The value of the property "${e}" must be an array`);break;case r:"string"!=typeof t&&"number"!=typeof t&&o(`${g}: The value of the property "${e}" must be a string`);break;case d:case l:"boolean"!=typeof t&&o(`${g}: The value of the property "${e}" must be a boolean value`);break;case a:I(t);break;case u:C(t);break;default:"string"!=typeof t&&o(`${g}: The value of the property "${e}" must be a string`)}}const s={...n,arrId:t};R.push(s)};let H=0;for(let e=0;e<B.length;e++){const t=B[e];if(S.includes(H)){const n=t.split(E).filter(Boolean);let s=-1,r="",i=!0,l=!1;for(let d=0;d<n.length;d++){const c=n[d],a="}"===c;if("{"===c)i?(i=!1,"{"!==n[d+1]&&d++):r+=c,s++;else if(a){if(-1===s&&o(`${b}: Handling curly braces in the Request Object`),1===s&&(l=!0),0===s){F(r,e),s--,H+=t.length;break}s--,r+=c}else l?M(c)&&o(`${b}: There is no empty space between the curly brackets`):r+=c}if(-1!==s){const n=e+1,i=B[n];void 0===i&&o(`${b}: Handling curly braces in the Request Object`);const d=i.split(E).filter(Boolean);let c="";for(let a=0;a<d.length;a++){const p=d[a],f="{"===p;if("}"===p){if(-1===s&&o(`${b}: Handling curly braces in the Request Object`),1===s&&(l=!0),0===s){const o=[...d];H+=t.length+i.length,o.splice(0,a+1),B[n]=o.join(""),F(r+c,e),s--,e++;break}s--,c+=p}else f?(c+=p,s++):l?M(p)&&o(`${b}: There is no empty space between the curly brackets`):c+=p}}-1!==s&&o(`${b}: Handling curly braces in the Request Object`)}else H+=t.length}0===R.length&&o(`${b}: Request not found`);for(let e=0;e<R.length;e++){const t=R[e],{arrId:o}=t,n=`\x3c!--hmpl${e}--\x3e`;B[o]=n,delete t.arrId}n=B.join("");let L=!1;const z=(e=>{const t=k(e.trim());(t.content.childNodes.length>1||1!==t.content.children.length&&8!==t.content.childNodes[0].nodeType)&&o(`${y}: Template include only one node with type Element or Comment`);const n=e=>{switch(e.nodeType){case Node.ELEMENT_NODE:if("pre"===e.tagName)return;break;case Node.TEXT_NODE:if(!/\S/.test(e.textContent))return void e.remove()}for(let t=0;t<e.childNodes.length;t++)n(e.childNodes.item(t))};n(t.content.childNodes[0]);let s=t.content.firstElementChild;if(!s){const e=t.content.firstChild,n=8===e?.nodeType;n?(L=n,s=e):o(`${y}: Element is undefined`)}return s})(n);return((n,r,c,f,h,$,b,v=!1)=>{const T=(n,r)=>{const c=n.src;if(c){const p=(n.method||"GET").toLowerCase();if(!(e=>"get"!==e&&"post"!==e&&"put"!==e&&"delete"!==e&&"patch"!==e)(p)){const s=n.after;s&&v&&o(`${y}: EventTarget is undefined`);const T=!n.hasOwnProperty(l),E="all"==(T||n.repeat?"all":"one"),O=!n.hasOwnProperty(d);let q=!h&&f.memo;O?q&&(s&&E||(q=!1)):s?n.memo?E?q=!0:o(`${g}: Memoization works in the enabled repetition mode`):q=!1:o(`${g}: Memoization works in the enabled repetition mode`);const A=!n.hasOwnProperty(a);let D=!$&&f.autoBody;if(A)!0===D&&(D=N),s||(D=!1);else if(s){let e=n[a];if(I(e),!0===D&&(D=N),!0===e&&(e=N),!1===e)D=!1;else{const t={...!1===D?w:D,...e};D=t}}else D=!1,o(`${g}: The "${a}" property does not work without the "${i}" property`);const R=!n.hasOwnProperty(u);let B=b?j:f.allowedContentTypes;if(!R){const e=n[u];C(e),B=e}const S=n.initId,M=n.nodeId;let F=n.indicators;if(F){const e=e=>{const{trigger:t,content:n}=e;t||o(`${g}: Failed to activate or detect the indicator`),n||o(`${g}: Failed to activate or detect the indicator`),-1===P.indexOf(t)&&"pending"!==t&&"rejected"!==t&&"error"!==t&&o(`${g}: Failed to activate or detect the indicator`);const s=k(n);return{...e,content:s}},t={},n=[];for(let s=0;s<F.length;s++){const r=e(F[s]),{trigger:i}=r;-1===n.indexOf(i)?n.push(i):o(`${g}: Indicator trigger must be unique`),t[`${i}`]=r.content}F=t}const H=(e,t=!1)=>{if(t){if(S){let t;for(let o=0;o<e.length;o++){const n=e[o];if(n.id===S){t=n.value;break}}return t||o(`${g}: ID referenced by request not found`),t}return{}}return S&&o(`${g}: ID referenced by request not found`),e},L=E&&s,z=(n,s,i,l,d,a=!1,f,u=!1,h,g)=>{const $=l.currentId;if(v)n||(n=r);else if(!n)if(h)n=h.el;else{let e;const{els:t}=l;for(let o=0;o<t.length;o++){const n=t[o];if(n.id===M){h=n,e=n.el;break}}e||o(`${y}: The specified DOM element is not valid or cannot be found`),n=e}let b;v||(L||F)&&(h||o(`${y}: The specified DOM element is not valid or cannot be found`),b=h.objNode,b||(b={id:$,nodes:null,parentNode:null,comment:n},q&&(b.memo={response:null},F&&(b.memo.isPending=!1)),h.objNode=b,l.dataObjects.push(b),l.currentId++));let N=H(s,a);const w=t(N);if(!w&&N&&(N={...N}),D&&D.formData&&g&&!w){const{type:e,target:t}=g;"submit"===e&&t&&t instanceof HTMLFormElement&&"FORM"===t.nodeName&&(N.body=new FormData(t,g.submitter))}const T=w?((e,t)=>{const o={};return void 0!==t&&(o.event=t),e({request:o})})(N,g):N;e(T)||void 0===T||o(`${m}: Expected an object with initialization options`),x(n,d,b,p,c,v,u,q,T,i,B,f,F)};let U=z;if(s){const e=(e,t,n,s,r,i,l,d,c,a,p)=>{const f=c.querySelectorAll(n);0===f.length&&o(`${y}: Selectors nodes not found`);const u=E?t=>{z(e,s,r,i,c,l,a,d,p,t)}:o=>{z(e,s,r,i,c,l,a,d,p,o);for(let e=0;e<f.length;e++)f[e].removeEventListener(t,u)};for(let e=0;e<f.length;e++)f[e].addEventListener(t,u)};if(s.indexOf(":")>0){const t=s.split(":"),o=t[0],n=t.slice(1).join(":");U=(t,s,r,i,l,d=!1,c,a=!1,p)=>{e(t,o,n,s,r,i,d,a,l,c,p)}}else o(`${g}: The "${i}" property doesn't work without EventTargets`)}else T||o(`${g}: The "${l}" property doesn't work without "${i}" property`);return U}o(`${g}: The "${s}" property has only GET, POST, PUT, PATCH or DELETE values`)}else o(`${g}: The "source" property are not found or empty`)};let E;if(v)c[0].el=n,E=T(c[0]);else{let e=-2;const t=n=>{if(e++,8==n.nodeType){let t=n.nodeValue;if(t&&t.startsWith(p)){t=t.slice(4);const s=Number(t),r=c[s];(Number.isNaN(s)||void 0===r)&&o(`${y}: Request object not found`),r.el=n,r.nodeId=e}}if(n.hasChildNodes()){const e=n.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(n);const s=[];for(let e=0;e<c.length;e++){const t=c[e];s.push(T(t,n))}if(c.length>1)E=(e,t,n,r,i,l=!1)=>{e||(e=i);const d=[],c=r.els;for(let i=0;i<c.length;i++){const a=c[i],p=a.el;null===p.parentNode&&o(`${y}: ParentNode is null`);const f={response:void 0};(0,s[i])(p,t,n,r,e,l,f,!0,a),d.push(f)}n.requests=d};else{const e=c[0];null===e.el.parentNode&&o(`${y}: ParentNode is null`),E=T(e,n)}}return r(E)})(z,(n=>(s={})=>{const r=z.cloneNode(!0),i={response:L?void 0:r},l={dataObjects:[],els:[],currentId:0};if(!L){let e=-2;const t=o=>{if(e++,8==o.nodeType){const t=o.nodeValue;if(t&&t.startsWith(p)){const t={el:o,id:e};l.els.push(t)}}if(o.hasChildNodes()){const e=o.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(r)}return e(s)||t(s)?((n=>{const s=e(n);s||t(n)||void 0===n||o(`${m}: Expected an object with initialization options`),s&&n.get&&(t(n.get)||o(`${m}: The "get" property has a function value`))})(s),n(void 0,s,i,l,r)):Array.isArray(s)&&((t=>{const n=[];for(let s=0;s<t.length;s++){const r=t[s];e(r)||o(`${g}: Options is of type object`),q(r);const{id:i}=r;"string"!=typeof r.id&&"number"!=typeof r.id&&o(`${g}: ID must be a string or a number`),n.indexOf(i)>-1?o(`${g}: ID with value "${i}" already exists`):n.push(i)}})(s),n(void 0,s,i,l,r,!0)),i}),R,f,h,A,D,L)},stringify:e=>JSON5.stringify(e)}}()}));